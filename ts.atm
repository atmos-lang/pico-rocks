val SHIP_FRAMES     = 4
val SHIP_ACC_DIV    = 10
val SHIP_VEL_MAX    = @{ x=W/2.5, y=H/2.5 }
val SHOT_DIM        = @{ x=W/50, y=H/100 }
val SHOT_COLOR      = @{ r=0xFF, g=0xFF, b=0x88 }
val METEOR_FRAMES   = 6
val METEOR_AWAIT    = 5000

func between (min, v, max) {
    ifs {
        v < min => min
        v > max => max
        else    => v
    }
}

func random_signal () {
    if (math.random(0,1) == 1) => 1 => -1
}

;; Simple "physics" to update Meteor/Shot `rect` position based on `vel` speed:
;;  * updates rect every 'step' frame
;;  * terminates when rect leaves the screen

func Move_T (rect, vel) {
    watching out_of_screen {
        every _,ms in :clock {
            val dt = ms / 1000
            set rect.x = rect.x + (vel.x * dt)
            set rect.y = rect.y + (vel.y * dt)
        }
    } where {
        out_of_screen = func () {
            ifs {
                rect.x < 0 => true
                rect.x > W => true
                rect.y < 0 => true
                rect.y > H => true
                else       => false
            }
        }
    }
}

func Meteor () {
    val dim = pico.get.size.image("imgs/meteor.gif")

    val y_sig = random_signal()

    val vx = (1 + (math.random(0,W/5))) * random_signal()
    val vy = (1 + (math.random(0,H/5))) * y_sig

    val w = dim.x / METEOR_FRAMES
    var dx = 0

    val rect = @{ x=x, y=y, w=w, h=dim.y } where {
        x = math.random(0,W)
        y = if y_sig==1 => 0 => H
    }
    set pub = @{
        tag  = :M,
        rect = rect,
    }

    par_or {
        val dt = math.random(1, METEOR_AWAIT)
        await @.dt
        par_or {
            await Move_T(rect, @{x=vx,y=vy})
        } with {
            await :collided
            pico.output.sound "snds/meteor.wav"
        }
    } with {
        every :draw {
            pico.zet.crop @{ x=dx, y=0, w=w, h=dim.y }
            pico.output.draw.image(rect, "imgs/meteor.gif")
            pico.zet.crop()
        }
    } with {
        val v = ((vx->math.pow(2)) + (vy->math.pow(2))) --> math.pow(1/2)
        var x = 0
        every _,ms in :clock {
            set x = x + ((v * ms) / 1000)
            set dx = (x % dim.x) - (x % w)
        }
    }
}

func Shot (V, pos, vy) {
    pico.output.sound "snds/shot.wav"
    val rect = @{ x=pos.x, y=pos.y, w=SHOT_DIM.x, h=SHOT_DIM.y }
    set pub = @{
        tag  = V.tag,
        rect = rect,
    }
    par_or {
        await :collided
    } with {
        await Move_T(rect, @{x=(W/3)*V.x, y=vy})
    } with {
        every :draw {
            pico.zet.color.draw(SHOT_COLOR)
            pico.output.draw.rect(rect)
        }
    }
}

func Ship (V, shots) {
    val dim = pico.get.size.image(V.img)
    val vel = @{x=0,y=0}
    val dy = dim.y / SHIP_FRAMES
    val rect = @{ x=V.pos.x, y=V.pos.y, w=dim.x, h=dy }

    set pub = @{
        tag  = V.tag,
        rect = rect,
    }

    var acc = @{x=0,y=0}
    var key
    spawn {
        par {
            every it in :key.dn {
                match it.key {
                    V.ctl.shot   => spawn [shots] Shot(V.shot, @{x=rect.x,y=rect.y}, vel.y)
                    V.ctl.move.l => set acc.x = -W/SHIP_ACC_DIV
                    V.ctl.move.r => set acc.x =  W/SHIP_ACC_DIV
                    V.ctl.move.u => set acc.y = -H/SHIP_ACC_DIV
                    V.ctl.move.d => set acc.y =  H/SHIP_ACC_DIV
                }
                set key = it.key
            }
        } with {
            every :key.up {
                set key = nil
                set acc = @{x=0,y=0}
            }
        }
    }

    watching :collided {
        par {
            every :draw {
                val frame = match key {
                    V.ctl.move.l => V.ctl.frame.l
                    V.ctl.move.r => V.ctl.frame.r
                    V.ctl.move.u => V.ctl.frame.u
                    V.ctl.move.d => V.ctl.frame.d
                    else => 0
                }
                pico.zet.crop @{ x=0, y=frame*dy, w=rect.w, h=dy }
                pico.output.draw.image(rect, V.img)
                pico.zet.crop()
            }
        } with {
            every _,ms in :clock {
                val dt = ms / 1000
                set vel.x = between(-SHIP_VEL_MAX.x, vel.x+(acc.x*dt), SHIP_VEL_MAX.x)
                set vel.y = between(-SHIP_VEL_MAX.y, vel.y+(acc.y*dt), SHIP_VEL_MAX.y)

                val x = rect.x + (vel.x*dt)
                val y = rect.y + (vel.y*dt)
                set rect.x = between(V.lim.x1, x, V.lim.x2-dim.x)
                set rect.y = between(0, y, H-dy)
            }
        }
    }

    watching @.100 {
        var d = dy / 2;
        par {
            every _,ms in :clock {
                set d = d + (((15*d)*ms)/1000)
            }
        } with {
            every :draw {
                pico.zet.color.draw(pico.color.red)
                pico.output.draw.oval @{ x=rect.x, y=rect.y, w=d, h=d }
            }
        }
    }
}
