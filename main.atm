require "atmos.env.pico"
set pico = require "pico"

set W, H = (640, 480)

pico.zet.title "The Battle of Ships"
pico.zet.size.window(W, H)
pico.zet.font(nil, H/15)

math.randomseed()

val Battle = require "battle" ;; actual battle gameplay

spawn {    ;; BACKGROUND
    ;;;
    ;; This task is the first to spawn, which makes the background image to
    ;; always be rendered first.
    ;;;
    val pt = pico.pos(50, 50)
    every :draw {
        pico.output.draw.image(pt, "imgs/bg.png")
    }
}

val points = @{ L=0, R=0 }

spawn {    ;; POINTS
    ;;;
    ;; Spawns the players points and place them at the bottom of the screen, in
    ;; opposite sides.
    ;; Points are incremented when the ship of the opponent is destroyed.
    ;; Since points must outlive each individual battle, we spawn them here,
    ;; outside the main game loop.
    ;;;
    val l = pico.pos(10, 90)
    val r = pico.pos(90, 90)
    every :draw {
        pico.zet.color.draw(pico.color.white)
        pico.output.draw.text(l, points.L)
        pico.output.draw.text(r, points.R)
    }
}

;; MAIN-LOOP
;;;
;; Starts the main game loop:
;;  - Shows the "press to start" message.
;;  - Runs the next battle with the actual gameplay.
;;  - Restarts whenever one of the ships is destroyed.
;;;
loop {
    ;; ENTER-TO-START
    watching :key.dn, :Return {
        ;;;
        ;; Spawns the blinking message, and awaits a :Return press.
        ;;;
        loop {
            ;; 500ms on
            watching @.500 {
                val pt = pico.pos(50, 50)
                every :draw {
                    pico.zet.color.draw(pico.color.white)
                    pico.output.draw.text(pt, "= PRESS ENTER TO START =")
                }
            }
            ;; 500ms off
            await @.500
        }
    }

    ;; Plays the restart sound.
    pico.output.sound "snds/start.wav"

    ;; spawns the actual battle
    pin battle = spawn Battle()

    ;; Pause with 'P':
    ;;  * awaits 'P' to toggle battle off
    ;;  * shows a "paused" image
    ;;  * awaits 'P' to toggle battle on
    spawn {
        loop {
            await(:key.dn, 'P')
            toggle battle(false)
            spawn {
                val pt = pico.pos(50, 50)
                every :draw {
                    pico.output.draw.image(pt, "imgs/pause.png")
                }
            }
            await(:key.dn, 'P')
            toggle battle(true)
        }
    }

    ;; Battle terminates:
    ;;  * awaits battle to return winner
    ;;  * increments winner points
    ;;  * awaits 1s before next battle
    val winner = await(battle)
    set points[winner] = points[winner] + 1
    await @1

    ;;;
    ;; Restarts the main loop.
    ;; Due to lexical memory management, only the points are preserved
    ;; between loop iterations.
    ;; All other tasks are guaranteed to abort and be reclaimed after this
    ;; point.
    ;;;
}
